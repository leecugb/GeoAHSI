from spectral import *
from osgeo import gdal
import os,re,shutil
from xml.dom.minidom import parse
import xml.dom.minidom
dem_dir='/media/lee/新加卷/unpacked'
def batch_process(pathname):
    img = open_image(pathname)
    spectrum=img.load()
    w=np.array([float(i) for i in img.metadata['wavelength']])/1000
    bp=np.array([float(i) for i in img.metadata['fwhm']])/1000
    resampled1={}
    for i in splib.index:
        res1=[]
        for x,y in zip(w,bp):
            mask=(splib.loc[i,'wave']<x+y/2)&(splib.loc[i,'wave']>x-y/2)
            if not mask.any():
                res1.append(np.nan)
            else:
                lamda=y/2
                sigma=(lamda**2/np.log(2))**0.5
                xx=splib.loc[i,'wave'][mask]-x
                wt=np.exp(-1*xx**2/sigma**2)
                temp=splib.loc[i,'rel'].astype('double')[mask]
                wt=wt[temp>0]
                temp=temp[temp>0]
                if len(temp)==0:
                    res1.append(np.nan)
                else:
                    res1.append((temp*wt).sum()/wt.sum())
        resampled1[i]=np.array(res1)
    t=spectrum.reshape([-1,b_n]).mean(0)
    mask=t<0.02
    chanels=np.arange(b_n)[~mask]
    wl=w[chanels]
    r,c,s=spectrum.shape
    mus_center=np.zeros(r*c,dtype='float')
    image=np.zeros([r*c,6],dtype='uint8')
    FIT_=np.zeros(r*c,dtype='float')
    DEPTH_=np.zeros(r*c,dtype='float')
    NUM_=np.zeros(r*c,dtype='uint8')
    for a,b in [(0,int(r/3)),(int(r/3),int(r*2/3)),(int(r*2/3),r)]:
        spectrum1=spectrum[a:b]
        spectrum1=spectrum1.reshape([-1,s])
        spectrum1=spectrum1[:,chanels]
        index=[]
        FIT=np.zeros([len(spectrum1),len(rf)])
        DEPTH=np.zeros([len(spectrum1),len(rf)])      
        k=0
        for key in rf.keys():
            index.append(key)
            try:
                fit,depth=judge_reference_entry(spectrum1, wl, key, resampled1, chanels)
            except (InvalidRangeError, InvalidLeftEndPointError, InvalidRightEndPointError):
                print(key)
                k = k+1
                continue
            FIT[:,k]=fit
            DEPTH[:,k]=depth
            k=k+1
        FIT[np.isnan(FIT)]=0
        DEPTH[np.isnan(DEPTH)]=0
        im=FIT.argmax(1)
        FIT_[a*c:b*c]   =FIT.flatten()[im+np.arange(len(im))*len(rf)]
        DEPTH_[a*c:b*c] =DEPTH.flatten()[im+np.arange(len(im))*len(rf)]
        NUM_[a*c:b*c]   =im
        
        images=np.zeros([len(spectrum1),3],dtype='uint8')
        k=0
        for i in im:
            images[k]=colors_dic[index[i]]
            k=k+1
        images[FIT.max(1)==0]=[0,0,0]
        image[a*c:b*c,:3]=images
        index_d=dict(zip(index,np.arange(index.__len__())))
        muscovite=[
             'calcite.7+muscovite.3',
             'chlorite+muscovite',
             'muscovite_lowAl',
             'muscovite_medAl',
             'muscovite_medhighAl',
             'muscovite_Fe-rich',
             'illite',
             'illite_gds4',
             'kaolin.5+muscovite_medAl',
             'kaolin+muscovite_mix_intimate',
             'kaolin.5+muscovite_medhighAl'
        ]
        for item in muscovite:
            t_mask=(im==index_d[item])&(FIT.max(1)>0)
            center=get_quadratic_center(spectrum1, wl, rf[item]['diagnostic'][0][1], t_mask)
            center[np.isnan(center)]=0
            mus_center[a*c:b*c]=mus_center[a*c:b*c]+center
    tem=spectrum[:,:,1].flatten()
    tem=(tem-tem.min())/(tem.max()-tem.min())*255
    image[:,3]=tem
    tem=spectrum[:,:,30].flatten()
    tem=(tem-tem.min())/(tem.max()-tem.min())*255
    image[:,4]=tem
    tem=spectrum[:,:,60].flatten()
    tem=(tem-tem.min())/(tem.max()-tem.min())*255
    image[:,5]=tem
    driver = gdal.GetDriverByName('GTiff')
    raster = driver.Create(os.path.split(pathname)[0]+'/lee1.tiff', c,r,6 ,gdal.GDT_Byte)
    raster.SetMetadataItem('AREA_OR_POINT', 'Point')
    for i in range(6):
        raster.GetRasterBand(i+1).WriteArray(image[:,i].reshape([r,c]))
        raster.FlushCache()
    raster=None
    
    
    image_=np.zeros([r*c,3],dtype='uint8')
    image_[mus_center<2.199]=table[0]
    image_[(mus_center>=2.199)&(mus_center<2.2)]=table[1]
    image_[(mus_center>=2.2)&(mus_center<2.201)]=table[2]
    image_[(mus_center>=2.201)&(mus_center<2.202)]=table[3]
    image_[(mus_center>=2.202)&(mus_center<2.203)]=table[4]
    image_[(mus_center>=2.203)&(mus_center<2.204)]=table[5]
    image_[(mus_center>=2.204)&(mus_center<2.205)]=table[6]
    image_[(mus_center>=2.205)&(mus_center<2.206)]=table[7]
    image_[(mus_center>=2.206)&(mus_center<2.207)]=table[8]
    image_[mus_center>=2.207]=table[9]
    image_[mus_center<2.195]=[0,0,0]
    image_[mus_center>=2.226]=[0,0,0]
    
    
    driver = gdal.GetDriverByName('GTiff')
    raster = driver.Create(os.path.split(pathname)[0]+'/mus1.tiff', c,r,3 ,gdal.GDT_Byte)
    raster.SetMetadataItem('AREA_OR_POINT', 'Point')
    
    for i in range(3):
        raster.GetRasterBand(i+1).WriteArray(image_[:,i].reshape([r,c]))
        raster.FlushCache()
    raster=None

    
    
    mask=FIT_>0
    images=np.zeros([r*c,3],dtype='uint8')
    for i in index:
        mask1=mask & (NUM_==index_d[i])
        if not mask1.any():
            continue
        dep=DEPTH_[mask1]
        dep=np.log(dep)
        dep=(dep-dep.min())/(dep.max()-dep.min())
        hsi=rgb2hsi((np.array(colors_dic[i])/255).reshape([-1,3]))[0]
        dep=dep*hsi[-1]/3+hsi[-1]*2/3
        #dep=dep*0.5/2+0.5/2
        im=np.zeros([mask1.sum(), 3])
        im[:,0]=hsi[0]
        im[:,1]=hsi[1]
        im[:,2]=dep
        images[mask1]=hsi2rgb(im)*255
    driver = gdal.GetDriverByName('GTiff')
    raster = driver.Create(os.path.split(pathname)[0]+'/color_enhanced2.tiff', c,r,3 ,gdal.GDT_Byte)
    raster.SetMetadataItem('AREA_OR_POINT', 'Point')
    for i in range(3):
        raster.GetRasterBand(i+1).WriteArray(images[:,i].reshape([r,c]))
        raster.FlushCache()
    raster=None
        
    rpb = None
    for i in os.listdir(os.path.split(pathname)[0]):
        if re.match(r'.*SW\.rpb$',i):
            rpb=i
    if rpb is None:
        print(pathname+': associated rpc file not found!')
        return
    shutil.copy(os.path.split(pathname)[0]+'/'+rpb, os.path.split(pathname)[0]+'/lee1.rpb')
    shutil.copy(os.path.split(pathname)[0]+'/'+rpb, os.path.split(pathname)[0]+'/mus1.rpb')
    shutil.copy(os.path.split(pathname)[0]+'/'+rpb, os.path.split(pathname)[0]+'/color_enhanced2.rpb')
    #meta=None
    #for i in os.listdir(os.path.split(pathname)[0]):
        #if re.match(r'GF5.*\.xml',i):
            #meta=i
    #if meta == None:
        #print(pathname+': associated meta file not found!')
        #return
    meta=os.path.split(pathname)[0]+'/'+os.path.split(os.path.split(pathname)[0])[1]+'.xml'
    name=os.path.split(os.path.split(pathname)[0])[1]
    if not os.path.isfile(meta):
        print(pathname+': associated meta file not found!')
        return
    DOMTree = xml.dom.minidom.parse(meta)
    collection = DOMTree.documentElement
    TopLeftLatitude = float(collection.getElementsByTagName('TopLeftLatitude')[0].childNodes[0].data)
    TopLeftLongitude = float(collection.getElementsByTagName('TopLeftLongitude')[0].childNodes[0].data)
    TopRightLatitude = float(collection.getElementsByTagName('TopRightLatitude')[0].childNodes[0].data)
    TopRightLongitude = float(collection.getElementsByTagName('TopRightLongitude')[0].childNodes[0].data)

    BottomRightLatitude = float(collection.getElementsByTagName('BottomRightLatitude')[0].childNodes[0].data)
    BottomRightLongitude = float(collection.getElementsByTagName('BottomRightLongitude')[0].childNodes[0].data)
    BottomLeftLatitude = float(collection.getElementsByTagName('BottomLeftLatitude')[0].childNodes[0].data)
    BottomLeftLongitude = float(collection.getElementsByTagName('BottomLeftLongitude')[0].childNodes[0].data)

    lat_max=(lambda x,y:x if x>y else y)(TopLeftLatitude, TopRightLatitude)
    lat_min=(lambda x,y:x if x<y else y)(BottomRightLatitude,BottomLeftLatitude)
    lon_max=(lambda x,y:x if x>y else y)(TopRightLongitude,BottomRightLongitude)
    lon_min=(lambda x,y:x if x<y else y)(TopLeftLongitude,BottomLeftLongitude)
    
    lat_center = (lat_max + lat_min) / 2
    lon_center = (lon_min + lon_max) / 2
    
    de=[]
    for i in range(int(np.floor(lat_min)),int(np.ceil(lat_max))):
        for j in range(int(np.floor(lon_min)),int(np.ceil(lon_max))):
            de.append(dem_dir+'/N{:02d}E{:03d}.hgt'.format(i,j))
    os.system('gdal_merge.py -of GTiff -o "'+os.path.split(pathname)[0]+'/dem.tif" '+ ' '.join(de))
    os.system('gdalwarp -overwrite -rpc -to "RPC_DEM='+os.path.split(pathname)[0]+'/dem.tif" '+'-t_srs '+'"+proj=utm +zone='+int(np.ceil(lon_center/6)+30).__str__() +' datum=WGS84 +units=m +no_defs"' +' -tr 30 30'+ ' -r near  "'+os.path.split(pathname)[0]+'/lee1.tiff" "' +os.path.split(pathname)[0]+'/'+name+'_mica_orth.tiff"')
    os.system('gdalwarp -overwrite -rpc -to "RPC_DEM='+os.path.split(pathname)[0]+'/dem.tif" '+'-t_srs '+'"+proj=utm +zone='+int(np.ceil(lon_center/6)+30).__str__() +' datum=WGS84 +units=m +no_defs"' +' -tr 30 30'+ ' -r near  "'+os.path.split(pathname)[0]+'/mus1.tiff" "' +os.path.split(pathname)[0]+'/'+name+'_mus_orth.tiff"')
    os.system('gdalwarp -overwrite -rpc -to "RPC_DEM='+os.path.split(pathname)[0]+'/dem.tif" '+'-t_srs '+'"+proj=utm +zone='+int(np.ceil(lon_center/6)+30).__str__() +' datum=WGS84 +units=m +no_defs"' +' -tr 30 30'+ ' -r near  "'+os.path.split(pathname)[0]+'/color_enhanced2.tiff" "' +os.path.split(pathname)[0]+'/'+name+'_color_enhanced_orth.tiff"')
